<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Round Robin (RR) Visualizer with Custom Processes</title>
    <!-- Updated Title -->
    <style id="dynamic-styles">
      /* --- Base Styles & Variables --- */
      :root {
        --bg-color: #f0f4f8; /* Lighter blue-gray */
        --container-bg: #ffffff;
        --section-bg: #ffffff; /* White cards */
        --header-color: #1a253c; /* Dark blue */
        --text-color: #334155; /* Slate gray */
        --border-color: #e2e8f0; /* Lighter border */
        --idle-color: #94a3b8; /* Slate */
        --ready-color: #f59e0b; /* Amber */
        --running-color: #10b981; /* Emerald */
        --terminated-color: #6b7280; /* Gray */
        --button-add: #3b82f6; /* Blue */
        --button-clear: #6b7280; /* Gray */
        --button-start: #22c55e; /* Green */
        --button-pause: #f59e0b; /* Amber */
        --button-reset: #ef4444; /* Red */
        --button-hover-factor: 0.9;
        --accent-blue: #3b82f6;

        --gantt-height: 45px;
        --queue-item-size: 38px;
        --base-font-size: 16px;
        --border-radius: 6px;
        --transition-speed: 0.25s;
        --box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --box-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
          sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        line-height: 1.6;
        font-size: var(--base-font-size);
        padding: 25px;
        display: flex;
        justify-content: center;
      }

      .container {
        background-color: var(--container-bg);
        padding: 30px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow-lg);
        width: 95%;
        max-width: 1300px; /* Wider layout */
        display: flex;
        flex-direction: column;
        gap: 25px; /* Spacing between main sections */
      }

      h1,
      h3,
      h4 {
        color: var(--header-color);
        margin-bottom: 10px; /* Reduced margin */
        text-align: center;
      }
      h1 {
        font-size: 1.8em;
        margin-bottom: 20px;
      }
      h3 {
        font-size: 1.3em;
        margin-top: 10px;
      }
      h4 {
        font-size: 1.1em;
        font-weight: 600;
        margin-bottom: 8px;
        text-align: left;
      }

      .section {
        background-color: var(--section-bg);
        padding: 20px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        border: 1px solid var(--border-color);
      }

      /* --- Custom Process Input Section --- */
      .custom-process-input {
        margin-bottom: 20px; /* Space below this section */
      }
      .input-form {
        display: flex;
        gap: 15px;
        align-items: flex-end; /* Align buttons with bottom of inputs */
        flex-wrap: wrap;
        margin-bottom: 15px;
      }
      .input-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .input-group label {
        font-weight: 600;
        font-size: 0.9em;
        color: var(--header-color);
      }
      .input-group input[type="number"] {
        padding: 7px 10px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        width: 100px; /* Fixed width for AT/BT inputs */
        text-align: center;
        font-size: 0.95em;
      }
      .input-group input[type="number"]:focus {
        outline: 2px solid var(--accent-blue);
        outline-offset: 1px;
        border-color: var(--accent-blue);
      }
      .input-group input[type="number"]:disabled {
        background-color: #e2e8f0;
        cursor: not-allowed;
      }
      .input-buttons button {
        padding: 9px 15px; /* Match control buttons */
        font-size: 0.9em;
        margin-left: 5px; /* Space between add/clear */
      }
      #add-process-button {
        background-color: var(--button-add);
      }
      #clear-processes-button {
        background-color: var(--button-clear);
      }

      /* --- Custom Process List Table --- */
      #custom-process-list-container {
        max-height: 150px; /* Limit height and make scrollable */
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-top: 10px;
      }
      .custom-process-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85em;
      }
      .custom-process-table th,
      .custom-process-table td {
        border-bottom: 1px solid var(--border-color);
        padding: 6px 10px;
        text-align: center;
      }
      .custom-process-table th {
        background-color: #f8fafc;
        position: sticky; /* Keep header visible on scroll */
        top: 0;
        font-weight: 600;
        color: var(--header-color);
      }
      .custom-process-table tr:last-child td {
        border-bottom: none;
      }
      .custom-process-table tr:hover {
        background-color: #eff6ff;
      }
      .custom-process-empty-text {
        padding: 10px;
        text-align: center;
        color: var(--idle-color);
        font-style: italic;
      }

      /* --- Controls --- */
      .controls {
        display: flex;
        gap: 15px;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        padding-bottom: 15px; /* Space below controls */
        border-bottom: 1px solid var(--border-color);
        margin-top: 10px; /* Space above controls */
      }
      .control-group {
        /* Existing styles */
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .control-group label {
        /* Existing styles */
        font-weight: 600;
        font-size: 0.9em;
        color: var(--header-color);
      }
      .control-group input[type="number"] {
        /* Existing styles */
        padding: 7px 10px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        width: 60px;
        text-align: center;
        font-size: 0.95em;
      }
      .control-group input[type="number"]:focus {
        /* Existing styles */
        outline: 2px solid var(--accent-blue);
        outline-offset: 1px;
        border-color: var(--accent-blue);
      }
      .control-group input[type="number"]:disabled {
        /* Existing styles */
        background-color: #e2e8f0;
        cursor: not-allowed;
      }

      /* Shared Button Styles */
      .controls button,
      .input-buttons button {
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 600;
        transition: background-color var(--transition-speed),
          transform 0.1s ease, filter var(--transition-speed);
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      }
      .controls button {
        padding: 9px 18px; /* Main controls slightly larger */
        font-size: 0.95em;
      }
      .controls button:disabled,
      .input-buttons button:disabled {
        background-color: #cbd5e1 !important; /* Light slate */
        cursor: not-allowed;
        filter: grayscale(50%);
      }
      .controls button:not(:disabled):hover,
      .input-buttons button:not(:disabled):hover {
        filter: brightness(var(--button-hover-factor));
      }
      .controls button:active:not(:disabled),
      .input-buttons button:active:not(:disabled) {
        transform: scale(0.97);
        filter: brightness(calc(var(--button-hover-factor) * 0.95));
      }
      #start-button {
        background-color: var(--button-start);
      }
      #pause-button {
        background-color: var(--button-pause);
      }
      #reset-button {
        background-color: var(--button-reset);
      }

      /* --- Status --- */
      .status {
        padding: 10px 15px;
        border-radius: var(--border-radius);
        text-align: center;
        font-weight: 600;
        font-size: 0.95em;
        min-height: 2em; /* Reserve space */
        transition: background-color var(--transition-speed),
          color var(--transition-speed), opacity var(--transition-speed);
        opacity: 0; /* Start hidden for fade-in */
      }
      .status.visible {
        opacity: 1;
      }
      .status-info {
        background-color: #ecfdf5;
        color: #059669;
        border: 1px solid #a7f3d0;
      }
      .status-error {
        background-color: #fef2f2;
        color: #dc2626;
        border: 1px solid #fecaca;
      }

      /* --- Visualization Area Layout --- */
      .visualization-area {
        display: grid;
        grid-template-columns: minmax(350px, 1.5fr) 2fr;
        gap: 25px;
      }
      .panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .panel h3 {
        margin-bottom: 15px;
      }

      /* --- Process Table --- */
      #process-table-container {
        overflow-x: auto;
      }
      .process-table {
        /* Existing styles */
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
        white-space: nowrap;
      }
      .process-table th,
      .process-table td {
        /* Existing styles */
        border: 1px solid var(--border-color);
        padding: 9px 12px;
        text-align: center;
      }
      .process-table th {
        /* Existing styles */
        background-color: #f8fafc;
        color: var(--header-color);
        font-weight: 600;
      }
      .process-table tr:nth-child(even) {
        background-color: #f8fafc;
      }
      .process-table tr:hover {
        background-color: #eff6ff;
      }
      .process-table td.state-cell {
        /* Existing styles */
        font-weight: 600;
        color: white;
        border-radius: 4px;
        padding: 5px 8px;
        transition: background-color var(--transition-speed) ease,
          color var(--transition-speed) ease;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
      }
      .state-New {
        background-color: #e2e8f0 !important;
        color: var(--text-color) !important;
        text-shadow: none;
      }
      .state-Ready {
        background-color: var(--ready-color) !important;
      }
      .state-Running {
        background-color: var(--running-color) !important;
      }
      .state-Terminated {
        background-color: var(--terminated-color) !important;
      }
      .process-table tr.highlight-running {
        background-color: #dcfce7 !important;
        font-weight: bold;
      }
      .process-table tr.highlight-running td {
        color: #15803d;
      }
      .process-table tr.highlight-running td.state-cell {
        color: white !important;
      }

      /* --- Ready Queue --- */
      #ready-queue {
        /* Existing styles */
        min-height: 60px;
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        padding: 15px;
        border: 1px dashed var(--border-color);
        border-radius: var(--border-radius);
      }
      .queue-item {
        /* Existing styles */
        width: var(--queue-item-size);
        height: var(--queue-item-size);
        line-height: var(--queue-item-size);
        text-align: center;
        font-weight: 600;
        border-radius: var(--border-radius);
        color: white;
        background-color: var(--ready-color);
        box-shadow: var(--box-shadow);
        transition: transform var(--transition-speed) ease,
          opacity var(--transition-speed) ease;
        opacity: 0;
        transform: scale(0.8) translateY(10px);
      }
      .queue-item.visible {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      .queue-empty-text {
        /* Existing styles */
        width: 100%;
        text-align: center;
        color: var(--idle-color);
        font-style: italic;
      }

      /* --- CPU & Clock --- */
      .cpu-clock-container {
        /* Existing styles */
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        text-align: center;
      }
      .cpu-clock-item {
        /* Existing styles */
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
      }
      .cpu-clock-item h4 {
        margin-bottom: 10px;
        text-align: center;
      }
      .cpu-box,
      .clock-box {
        /* Existing styles */
        padding: 8px 15px;
        font-weight: 700;
        font-size: 1.1em;
        border-radius: 4px;
        display: inline-block;
        min-width: 60px;
        text-align: center;
      }
      .cpu-box {
        background-color: var(--idle-color);
        color: white;
        transition: background-color var(--transition-speed) ease,
          color var(--transition-speed) ease;
      }
      .cpu-box.running {
        background-color: var(--running-color);
      }
      .clock-box {
        background-color: #f8fafc;
        border: 1px solid var(--border-color);
        color: var(--header-color);
      }

      /* --- Gantt Chart --- */
      .gantt-section {
        /* Existing styles */
        padding-bottom: 35px;
        position: relative;
      }
      .gantt-chart-container {
        /* Existing styles */
        height: calc(var(--gantt-height) + 25px);
        overflow-x: auto;
        overflow-y: hidden;
        padding: 10px 5px;
        position: relative;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        background-color: #f8fafc;
        margin-top: 10px;
        max-width: 800px; /* Ensure this doesn't break layout */
      }
      .gantt-chart-track {
        /* Existing styles */
        display: flex;
        height: var(--gantt-height);
        min-width: 100%;
        width: fit-content;
        position: relative;
        border-left: 1px solid #999;
      }
      .gantt-block {
        /* Existing styles */
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 600;
        font-size: 0.9em;
        color: white;
        text-align: center;
        border-right: 1px solid rgba(0, 0, 0, 0.15);
        box-sizing: border-box;
        flex-shrink: 0;
        overflow: hidden;
        white-space: nowrap;
        border-radius: 3px;
        margin: 1px 0;
        opacity: 0;
        animation: fade-in 0.4s ease forwards;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
      }
      @keyframes fade-in {
        to {
          opacity: 1;
        }
      }
      .gantt-block.idle {
        background-color: var(--idle-color);
        color: #e2e8f0;
      }
      .gantt-time-markers {
        /* Existing styles */
        position: absolute;
        bottom: 0px;
        left: 5px;
        width: calc(100% - 10px);
        height: 20px;
        margin-top: 5px;
      }
      .gantt-time-marker {
        /* Existing styles */
        position: absolute;
        bottom: 0;
        font-size: 0.8em;
        color: #475569;
        transform: translateX(-50%);
        border-left: 1px solid #cbd5e1;
        height: 5px;
        padding-left: 3px;
      }
      .gantt-time-marker span {
        display: inline-block;
        transform: translateY(-18px);
      }
      .gantt-axis-label {
        /* Existing styles */
        position: absolute;
        bottom: 0px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.85em;
        font-weight: 600;
        color: var(--header-color);
      }

      /* --- Metrics --- */
      .metrics {
        text-align: center;
      }
      .metrics p {
        /* Existing styles */
        font-weight: 600;
        font-size: 1.05em;
        color: var(--header-color);
        margin-bottom: 8px;
        background-color: #f8fafc;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid var(--border-color);
        display: inline-block;
        min-width: 250px;
        margin-left: 10px;
        margin-right: 10px;
      }
      .metrics p span {
        font-weight: 700;
        color: var(--accent-blue);
      }

      /* --- Responsive Adjustments --- */
      @media (max-width: 1100px) {
        .visualization-area {
          grid-template-columns: 1fr;
        }
        .left-panel {
          max-width: none;
        }
      }
      @media (max-width: 768px) {
        body {
          padding: 15px;
        }
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 1.5em;
        }
        .input-form {
          flex-direction: column;
          align-items: stretch;
        }
        .input-group input[type="number"] {
          width: 100%;
        } /* Full width on mobile */
        .input-buttons {
          display: flex;
          justify-content: center;
          gap: 10px;
          margin-top: 10px;
        }
        .input-buttons button {
          flex-grow: 1;
        } /* Buttons share space */

        .controls {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
        }
        .control-group {
          justify-content: center;
        }
        .controls button {
          padding: 10px 16px;
          font-size: 1em;
        }
        .cpu-clock-container {
          grid-template-columns: 1fr;
        }
        .metrics p {
          display: block;
          margin-left: 0;
          margin-right: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- Structure will be created by JavaScript -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- Configuration ---
        const SIMULATION_SPEED_MS = 650;
        const DEFAULT_TIME_QUANTUM = 4;

        // --- Default Test Data (Used if no custom processes are added) ---
        const defaultInitialProcesses = [
          { id: "P1", arrivalTime: 0, burstTime: 8 },
          { id: "P2", arrivalTime: 1, burstTime: 4 },
          { id: "P3", arrivalTime: 2, burstTime: 9 },
          { id: "P4", arrivalTime: 3, burstTime: 5 },
          { id: "P5", arrivalTime: 4, burstTime: 2 },
          { id: "P6", arrivalTime: 5, burstTime: 6 },
          { id: "P7", arrivalTime: 6, burstTime: 3 },
        ];

        // --- State Variables ---
        let processes = [];
        let customProcessesData = []; // Holds user-added processes
        let customProcessCounter = 1; // For generating unique IDs like P1, P2...
        let readyQueue = [];
        let ganttData = [];
        let currentTime = 0;
        let runningProcessId = null;
        let runningProcessRow = null;
        let completedProcessesCount = 0;
        let simulationInterval = null;
        let isPaused = false;
        let lastGanttEntry = null;
        let timeQuantum = DEFAULT_TIME_QUANTUM;
        let currentSliceTime = 0;

        const processColors = [
          "#3b82f6",
          "#ef4444",
          "#10b981",
          "#f59e0b",
          "#8b5cf6",
          "#06b6d4",
          "#ec4899",
          "#65a30d",
          "#d97706",
          "#0ea5e9",
        ];

        // --- DOM Elements ---
        let container,
          customProcessInputSection, // New Section
          arrivalTimeInput, // New Input
          burstTimeInput, // New Input
          addProcessButton, // New Button
          clearProcessesButton, // New Button
          customProcessListTableBody, // New Table Body
          customProcessListContainer, // Container for scrolling
          controlsDiv,
          visualizationDiv,
          processTableContainer,
          readyQueueDiv,
          cpuDiv,
          clockDiv,
          ganttChartContainer,
          ganttChartTrack,
          ganttTimeMarkersContainer,
          ganttAxisLabel,
          metricsDiv,
          statusDiv;
        let startButton, pauseButton, resetButton, timeQuantumInput;

        // --- Core Functions ---

        // 1. Create DOM (Includes new Custom Process Input section)
        function createDOM() {
          container = document.createElement("div");
          container.className = "container";

          const title = document.createElement("h1");
          title.textContent =
            "Round Robin (RR) Visualizer with Custom Processes";
          container.appendChild(title);

          // --- Custom Process Input Section ---
          customProcessInputSection = document.createElement("div");
          customProcessInputSection.className = "section custom-process-input";
          const customInputTitle = document.createElement("h3");
          customInputTitle.textContent = "Add Custom Processes (Optional)";
          customProcessInputSection.appendChild(customInputTitle);

          const inputForm = document.createElement("div");
          inputForm.className = "input-form";

          // Arrival Time Input
          const atGroup = document.createElement("div");
          atGroup.className = "input-group";
          const atLabel = document.createElement("label");
          atLabel.htmlFor = "arrival-time";
          atLabel.textContent = "Arrival Time:";
          arrivalTimeInput = document.createElement("input");
          arrivalTimeInput.type = "number";
          arrivalTimeInput.id = "arrival-time";
          arrivalTimeInput.min = "0";
          arrivalTimeInput.step = "1";
          arrivalTimeInput.placeholder = "e.g., 0";
          atGroup.appendChild(atLabel);
          atGroup.appendChild(arrivalTimeInput);
          inputForm.appendChild(atGroup);

          // Burst Time Input
          const btGroup = document.createElement("div");
          btGroup.className = "input-group";
          const btLabel = document.createElement("label");
          btLabel.htmlFor = "burst-time";
          btLabel.textContent = "Burst Time:";
          burstTimeInput = document.createElement("input");
          burstTimeInput.type = "number";
          burstTimeInput.id = "burst-time";
          burstTimeInput.min = "1"; // Burst time must be at least 1
          burstTimeInput.step = "1";
          burstTimeInput.placeholder = "e.g., 5";
          btGroup.appendChild(btLabel);
          btGroup.appendChild(burstTimeInput);
          inputForm.appendChild(btGroup);

          // Input Buttons (Add/Clear)
          const inputButtonsDiv = document.createElement("div");
          inputButtonsDiv.className = "input-buttons";
          addProcessButton = document.createElement("button");
          addProcessButton.id = "add-process-button";
          addProcessButton.textContent = "Add Process";
          addProcessButton.addEventListener("click", addCustomProcess);
          clearProcessesButton = document.createElement("button");
          clearProcessesButton.id = "clear-processes-button";
          clearProcessesButton.textContent = "Clear List";
          clearProcessesButton.addEventListener("click", clearCustomProcesses);
          inputButtonsDiv.appendChild(addProcessButton);
          inputButtonsDiv.appendChild(clearProcessesButton);
          inputForm.appendChild(inputButtonsDiv);

          customProcessInputSection.appendChild(inputForm);

          // Custom Process List Display
          const listTitle = document.createElement("h4");
          listTitle.textContent = "Custom Process List";
          listTitle.style.textAlign = "left";
          listTitle.style.marginTop = "15px";
          customProcessInputSection.appendChild(listTitle);
          customProcessListContainer = document.createElement("div");
          customProcessListContainer.id = "custom-process-list-container";
          const customTable = document.createElement("table");
          customTable.className = "custom-process-table";
          customTable.innerHTML = `<thead><tr><th>ID</th><th>Arrival</th><th>Burst</th></tr></thead>`;
          customProcessListTableBody = document.createElement("tbody");
          customTable.appendChild(customProcessListTableBody);
          customProcessListContainer.appendChild(customTable); // Add table to container
          customProcessInputSection.appendChild(customProcessListContainer); // Add container to section

          container.appendChild(customProcessInputSection); // Add section to main container

          // --- End Custom Process Input Section ---

          // Controls (Start/Pause/Reset/TQ)
          controlsDiv = document.createElement("div");
          controlsDiv.className = "controls";
          // Time Quantum Input Group
          const tqGroup = document.createElement("div");
          tqGroup.className = "control-group";
          const tqLabel = document.createElement("label");
          tqLabel.htmlFor = "time-quantum";
          tqLabel.textContent = "Time Quantum (TQ):";
          timeQuantumInput = document.createElement("input");
          timeQuantumInput.type = "number";
          timeQuantumInput.id = "time-quantum";
          timeQuantumInput.value = DEFAULT_TIME_QUANTUM;
          timeQuantumInput.min = "1";
          timeQuantumInput.step = "1";
          tqGroup.appendChild(tqLabel);
          tqGroup.appendChild(timeQuantumInput);
          controlsDiv.appendChild(tqGroup);
          // Control Buttons
          startButton = document.createElement("button");
          startButton.id = "start-button";
          startButton.textContent = "Start";
          startButton.addEventListener("click", startSimulation);
          pauseButton = document.createElement("button");
          pauseButton.id = "pause-button";
          pauseButton.textContent = "Pause";
          pauseButton.disabled = true;
          pauseButton.addEventListener("click", pauseSimulation);
          resetButton = document.createElement("button");
          resetButton.id = "reset-button";
          resetButton.textContent = "Reset";
          resetButton.addEventListener("click", resetSimulation);
          controlsDiv.appendChild(startButton);
          controlsDiv.appendChild(pauseButton);
          controlsDiv.appendChild(resetButton);
          container.appendChild(controlsDiv);

          // Status Display
          statusDiv = document.createElement("div");
          statusDiv.className = "status status-info";
          statusDiv.id = "status-message";
          container.appendChild(statusDiv);

          // Visualization Area (Grid Layout) - Same structure as before
          visualizationDiv = document.createElement("div");
          visualizationDiv.className = "visualization-area";
          // Left Panel (Process Details Table)
          const leftPanel = document.createElement("div");
          leftPanel.className = "panel left-panel section";
          const tableTitle = document.createElement("h3");
          tableTitle.textContent = "Process Details";
          processTableContainer = document.createElement("div");
          processTableContainer.id = "process-table-container";
          leftPanel.appendChild(tableTitle);
          leftPanel.appendChild(processTableContainer);
          // Right Panel (Queue, CPU, Clock, Gantt, Metrics)
          const rightPanel = document.createElement("div");
          rightPanel.className = "panel right-panel";
          // Ready Queue
          const queueSection = document.createElement("div");
          queueSection.className = "section";
          const queueTitle = document.createElement("h3");
          queueTitle.textContent = "Ready Queue (FIFO)";
          readyQueueDiv = document.createElement("div");
          readyQueueDiv.id = "ready-queue";
          queueSection.appendChild(queueTitle);
          queueSection.appendChild(readyQueueDiv);
          // CPU & Clock
          const cpuClockSection = document.createElement("div");
          cpuClockSection.className = "section cpu-clock-container";
          const cpuItem = document.createElement("div");
          cpuItem.className = "cpu-clock-item";
          const cpuTitle = document.createElement("h4");
          cpuTitle.textContent = "CPU";
          cpuDiv = document.createElement("div");
          cpuDiv.id = "cpu-status";
          cpuDiv.className = "cpu-box idle";
          cpuDiv.textContent = "Idle";
          cpuItem.appendChild(cpuTitle);
          cpuItem.appendChild(cpuDiv);
          const clockItem = document.createElement("div");
          clockItem.className = "cpu-clock-item";
          const clockTitle = document.createElement("h4");
          clockTitle.textContent = "Clock";
          clockDiv = document.createElement("div");
          clockDiv.id = "clock";
          clockDiv.className = "clock-box";
          clockDiv.textContent = "0";
          clockItem.appendChild(clockTitle);
          clockItem.appendChild(clockDiv);
          cpuClockSection.appendChild(cpuItem);
          cpuClockSection.appendChild(clockItem);
          // Gantt Chart
          const ganttSection = document.createElement("div");
          ganttSection.className = "section gantt-section";
          const ganttTitle = document.createElement("h3");
          ganttTitle.textContent = "Gantt Chart";
          ganttChartContainer = document.createElement("div");
          ganttChartContainer.id = "gantt-chart";
          ganttChartContainer.className = "gantt-chart-container";
          ganttChartTrack = document.createElement("div");
          ganttChartTrack.className = "gantt-chart-track";
          ganttTimeMarkersContainer = document.createElement("div");
          ganttTimeMarkersContainer.className = "gantt-time-markers";
          ganttAxisLabel = document.createElement("div");
          ganttAxisLabel.className = "gantt-axis-label";
          ganttAxisLabel.textContent = "Time";
          ganttChartContainer.appendChild(ganttChartTrack);
          ganttChartContainer.appendChild(ganttTimeMarkersContainer);
          ganttSection.appendChild(ganttTitle);
          ganttSection.appendChild(ganttChartContainer);
          ganttSection.appendChild(ganttAxisLabel);
          // Metrics
          metricsDiv = document.createElement("div");
          metricsDiv.id = "metrics";
          metricsDiv.className = "metrics section";
          metricsDiv.style.display = "none";
          // Append right panel sections
          rightPanel.appendChild(queueSection);
          rightPanel.appendChild(cpuClockSection);
          rightPanel.appendChild(ganttSection);
          rightPanel.appendChild(metricsDiv);
          // Append panels to visualization area
          visualizationDiv.appendChild(leftPanel);
          visualizationDiv.appendChild(rightPanel);
          container.appendChild(visualizationDiv);

          document.body.appendChild(container);
        }

        // --- Custom Process Handling ---

        function addCustomProcess() {
          const arrivalTime = parseInt(arrivalTimeInput.value, 10);
          const burstTime = parseInt(burstTimeInput.value, 10);

          // Validation
          if (isNaN(arrivalTime) || arrivalTime < 0) {
            updateStatus(
              "Error: Arrival Time must be a non-negative integer.",
              false
            );
            return;
          }
          if (isNaN(burstTime) || burstTime <= 0) {
            updateStatus(
              "Error: Burst Time must be a positive integer.",
              false
            );
            return;
          }

          const newProcess = {
            id: `P${customProcessCounter}`,
            arrivalTime: arrivalTime,
            burstTime: burstTime,
          };

          customProcessesData.push(newProcess);
          customProcessCounter++;

          renderCustomProcessList(); // Update the display list
          // Clear inputs for next entry
          arrivalTimeInput.value = "";
          burstTimeInput.value = "";
          arrivalTimeInput.focus(); // Set focus back to arrival time
          updateStatus(
            `Process ${newProcess.id} added. Add more or Start.`,
            true
          );
        }

        function clearCustomProcesses() {
          customProcessesData = [];
          customProcessCounter = 1; // Reset counter
          renderCustomProcessList(); // Update the display list
          updateStatus(
            "Custom process list cleared. Add new or use defaults.",
            true
          );
        }

        function renderCustomProcessList() {
          customProcessListTableBody.innerHTML = ""; // Clear existing rows
          if (customProcessesData.length === 0) {
            customProcessListTableBody.innerHTML = `<tr><td colspan="3" class="custom-process-empty-text">No custom processes added. Using defaults if started.</td></tr>`;
          } else {
            customProcessesData.forEach((p) => {
              const row = document.createElement("tr");
              row.innerHTML = `
                        <td>${p.id}</td>
                        <td>${p.arrivalTime}</td>
                        <td>${p.burstTime}</td>
                    `;
              customProcessListTableBody.appendChild(row);
            });
          }
          // Disable clear button if list is empty
          clearProcessesButton.disabled = customProcessesData.length === 0;
        }

        // --- Simulation Initialization (Uses custom or default data) ---
        function initializeSimulation() {
          const tqValue = parseInt(timeQuantumInput.value, 10);
          timeQuantum =
            !isNaN(tqValue) && tqValue > 0 ? tqValue : DEFAULT_TIME_QUANTUM;
          timeQuantumInput.value = timeQuantum;

          // Determine which process data to use
          const sourceData =
            customProcessesData.length > 0
              ? customProcessesData
              : defaultInitialProcesses;

          // Deep copy and initialize process state
          processes = JSON.parse(JSON.stringify(sourceData)).map((p) => ({
            ...p,
            remainingBurstTime: p.burstTime,
            state: "New",
            startTime: -1,
            completionTime: -1,
            waitingTime: 0,
            turnaroundTime: 0,
            _lastExecutionTime: p.arrivalTime,
            _color: getProcessColor(p.id),
          }));

          // Reset simulation state variables
          readyQueue = [];
          ganttData = [];
          currentTime = 0;
          runningProcessId = null;
          unhighlightProcessRow();
          completedProcessesCount = 0;
          lastGanttEntry = null;
          isPaused = false;
          currentSliceTime = 0;

          if (simulationInterval) {
            clearInterval(simulationInterval);
            simulationInterval = null;
          }

          // Render initial UI state
          renderProcessTable();
          renderReadyQueue();
          renderCPU();
          renderGanttChart();
          clockDiv.textContent = "0";
          metricsDiv.innerHTML = "";
          metricsDiv.style.display = "none";
          updateStatus(
            "Simulation reset. Add/modify processes or press Start.",
            true
          );

          // Reset button states and enable inputs
          startButton.disabled = false;
          pauseButton.textContent = "Pause";
          pauseButton.disabled = true;
          timeQuantumInput.disabled = false;
          arrivalTimeInput.disabled = false;
          burstTimeInput.disabled = false;
          addProcessButton.disabled = false;
          clearProcessesButton.disabled = customProcessesData.length === 0; // Re-enable based on list content

          renderCustomProcessList(); // Ensure custom list display is up-to-date
        }

        // --- Rendering Functions (Mostly Unchanged) ---
        function renderProcessTable() {
          let tableHTML = `<table class="process-table"><thead><tr>
                    <th>ID</th><th>Arrival</th><th>Burst</th>
                    <th>Remain</th><th>State</th><th>Wait</th><th>TAT</th>
                </tr></thead><tbody>`;
          processes.sort((a, b) =>
            a.id.localeCompare(b.id, undefined, { numeric: true })
          );
          processes.forEach((p) => {
            tableHTML += `<tr id="proc-row-${p.id}">
                        <td>${p.id}</td><td>${p.arrivalTime}</td><td>${
              p.burstTime
            }</td>
                        <td class="remaining-time">${p.remainingBurstTime}</td>
                        <td class="state-cell state-${p.state}">${p.state}</td>
                        <td class="wait-time">${p.waitingTime}</td>
                        <td class="turnaround-time">${
                          p.turnaroundTime > 0 ? p.turnaroundTime : "-"
                        }</td>
                    </tr>`;
          });
          tableHTML += `</tbody></table>`;
          processTableContainer.innerHTML = tableHTML;
          unhighlightProcessRow();
        }
        function renderReadyQueue() {
          readyQueueDiv.innerHTML = "";
          if (readyQueue.length === 0) {
            const emptyText = document.createElement("div");
            emptyText.className = "queue-empty-text";
            emptyText.textContent = "Queue Empty";
            readyQueueDiv.appendChild(emptyText);
          } else {
            readyQueue.forEach((pid, index) => {
              const item = document.createElement("div");
              item.className = "queue-item";
              item.textContent = pid;
              const proc = findProcessById(pid);
              item.style.backgroundColor = proc
                ? proc._color
                : "var(--idle-color)";
              readyQueueDiv.appendChild(item);
              setTimeout(() => item.classList.add("visible"), 30 * index);
            });
          }
        }
        function renderCPU() {
          unhighlightProcessRow();
          if (runningProcessId) {
            const proc = findProcessById(runningProcessId);
            cpuDiv.textContent = runningProcessId;
            cpuDiv.className = "cpu-box running";
            cpuDiv.style.backgroundColor = proc
              ? proc._color
              : "var(--running-color)";
            highlightProcessRow(runningProcessId);
          } else {
            cpuDiv.textContent = "Idle";
            cpuDiv.className = "cpu-box idle";
            cpuDiv.style.backgroundColor = "var(--idle-color)";
          }
        }
        function highlightProcessRow(processId) {
          unhighlightProcessRow();
          runningProcessRow = document.getElementById(`proc-row-${processId}`);
          if (runningProcessRow) {
            runningProcessRow.classList.add("highlight-running");
          }
        }
        function unhighlightProcessRow() {
          if (runningProcessRow) {
            runningProcessRow.classList.remove("highlight-running");
            runningProcessRow = null;
          }
        }
        function renderGanttChart() {
          ganttChartTrack.innerHTML = "";
          ganttTimeMarkersContainer.innerHTML = "";
          if (ganttData.length === 0 && currentTime === 0) {
            addTimeMarker(0);
            return;
          }
          const blockPixelWidth = 30;
          let totalDuration = 0;
          const timePoints = new Set([0]);

          ganttData.forEach((block) => {
            const blockDiv = document.createElement("div");
            blockDiv.className = "gantt-block";
            const duration = block.end - block.start;
            blockDiv.style.width = `${duration * blockPixelWidth}px`;
            totalDuration = Math.max(totalDuration, block.end);
            timePoints.add(block.end);

            if (block.isIdle) {
              blockDiv.classList.add("idle");
              blockDiv.textContent = `Idle`;
              blockDiv.title = `Idle from ${block.start} to ${block.end}`;
            } else {
              const proc = findProcessById(block.processId);
              blockDiv.textContent = `${block.processId}`;
              blockDiv.style.backgroundColor = proc ? proc._color : "gray";
              blockDiv.title = `${block.processId} from ${block.start} to ${block.end}`;
            }
            ganttChartTrack.appendChild(blockDiv);
          });

          const sortedTimePoints = Array.from(timePoints).sort((a, b) => a - b);
          sortedTimePoints.forEach((time) =>
            addTimeMarker(time, blockPixelWidth)
          );

          ganttChartTrack.style.minWidth = `${
            totalDuration * blockPixelWidth
          }px`;
          ganttChartContainer.scrollLeft = ganttChartTrack.scrollWidth;
        }
        function addTimeMarker(time, pixelWidth = 30) {
          const marker = document.createElement("div");
          marker.className = "gantt-time-marker";
          marker.style.left = `${time * pixelWidth}px`;
          const markerLabel = document.createElement("span");
          markerLabel.textContent = time;
          marker.appendChild(markerLabel);
          ganttTimeMarkersContainer.appendChild(marker);
        }
        function renderMetrics() {
          if (
            processes.length === 0 ||
            completedProcessesCount !== processes.length
          )
            return;
          let totalWT = 0,
            totalTAT = 0;
          processes.forEach((p) => {
            totalWT += p.waitingTime;
            totalTAT += p.turnaroundTime;
          });
          const avgWT = (totalWT / processes.length).toFixed(2);
          const avgTAT = (totalTAT / processes.length).toFixed(2);
          metricsDiv.innerHTML = `
              <h3>Performance Metrics</h3>
              <p>Avg. Waiting Time: <span>${avgWT}</span></p>
              <p>Avg. Turnaround Time: <span>${avgTAT}</span></p>`;
          metricsDiv.style.display = "block";
        }
        function updateProcessTableRow(process) {
          const row = document.getElementById(`proc-row-${process.id}`);
          if (row) {
            row.querySelector(".remaining-time").textContent =
              process.remainingBurstTime;
            const stateCell = row.querySelector(".state-cell");
            stateCell.textContent = process.state;
            stateCell.className = `state-cell state-${process.state}`;
            row.querySelector(".wait-time").textContent = process.waitingTime;
            row.querySelector(".turnaround-time").textContent =
              process.completionTime !== -1 ? process.turnaroundTime : "-";
          }
        }
        function getProcessColor(processId) {
          if (!processId || processId === "Idle") return "var(--idle-color)";
          try {
            // Use the number part of the ID (P1 -> 1, P10 -> 10) for consistent coloring
            const num = parseInt(processId.substring(1), 10);
            if (isNaN(num)) return processColors[0]; // Fallback
            return processColors[
              (num - 1 + processColors.length) % processColors.length
            ];
          } catch (e) {
            return processColors[0]; // Default color
          }
        }
        function findProcessById(id) {
          return processes.find((p) => p.id === id);
        }
        function addGanttBlock(processId, isIdle) {
          const currentEntry = { id: processId, isIdle: isIdle };
          if (
            ganttData.length > 0 &&
            lastGanttEntry &&
            lastGanttEntry.id === currentEntry.id &&
            lastGanttEntry.isIdle === currentEntry.isIdle
          ) {
            ganttData[ganttData.length - 1].end = currentTime + 1;
          } else {
            ganttData.push({
              processId: processId,
              start: currentTime,
              end: currentTime + 1,
              isIdle: isIdle,
            });
            lastGanttEntry = currentEntry;
          }
          renderGanttChart();
        }

        // --- Simulation Logic (RR Implementation - Unchanged) ---
        function simulationStep() {
          if (
            isPaused ||
            (processes.length > 0 &&
              completedProcessesCount === processes.length)
          )
            return; // Check if processes exist before checking completion

          // Handle case where no processes were defined (edge case)
          if (processes.length === 0 && currentTime === 0) {
            updateStatus(
              "No processes defined. Add custom processes or Reset to use defaults.",
              false
            );
            endSimulation(); // Stop if no processes
            return;
          }
          // Check if simulation can end (no running process, queue empty, all processes arrived and none left to run)
          if (
            runningProcessId === null &&
            readyQueue.length === 0 &&
            processes.every(
              (p) => p.state === "Terminated" || p.arrivalTime > currentTime
            )
          ) {
            const allTerminated = processes.every(
              (p) => p.state === "Terminated"
            );
            if (allTerminated && completedProcessesCount === processes.length) {
              // Already handled below
            } else if (
              processes.length > 0 &&
              !allTerminated &&
              processes.every(
                (p) => p.arrivalTime > currentTime || p.state === "Terminated"
              )
            ) {
              // If idle and waiting for future arrivals
              addGanttBlock(null, true); // Add Idle block
            } else if (
              completedProcessesCount === processes.length &&
              processes.length > 0
            ) {
              // Final check if endSimulation wasn't called yet
              endSimulation();
              return;
            }
          }

          let stateChanged = false;

          // A. Check for new arrivals & add to ready queue
          processes.forEach((p) => {
            if (p.state === "New" && p.arrivalTime <= currentTime) {
              p.state = "Ready";
              p._lastExecutionTime = currentTime;
              readyQueue.push(p.id);
              updateProcessTableRow(p);
              stateChanged = true;
            }
          });

          let processCompletedOrPreempted = false;

          // B. Handle running process
          if (runningProcessId) {
            const runningProc = findProcessById(runningProcessId);
            runningProc.remainingBurstTime--;
            currentSliceTime++;
            addGanttBlock(runningProc.id, false);
            updateProcessTableRow(runningProc);

            // Check for Completion
            if (runningProc.remainingBurstTime === 0) {
              runningProc.state = "Terminated";
              runningProc.completionTime = currentTime + 1;
              runningProc.turnaroundTime =
                runningProc.completionTime - runningProc.arrivalTime;
              runningProc.waitingTime =
                runningProc.turnaroundTime - runningProc.burstTime;
              updateProcessTableRow(runningProc);
              completedProcessesCount++;
              runningProcessId = null;
              currentSliceTime = 0;
              processCompletedOrPreempted = true;
              stateChanged = true;
            }
            // Check for Time Quantum Expiry
            else if (currentSliceTime === timeQuantum) {
              runningProc.state = "Ready";
              runningProc._lastExecutionTime = currentTime + 1;
              readyQueue.push(runningProc.id); // Add back to the END
              updateProcessTableRow(runningProc);
              runningProcessId = null;
              currentSliceTime = 0;
              processCompletedOrPreempted = true;
              stateChanged = true;
            }
          } else if (processes.length > 0) {
            // Only add idle block if processes exist
            // Check if any process COULD run or arrive later
            const futureArrival = processes.some(
              (p) => p.state === "New" && p.arrivalTime > currentTime
            );
            const waitingInQueue = readyQueue.length > 0;
            if (
              !waitingInQueue &&
              !futureArrival &&
              completedProcessesCount < processes.length
            ) {
              // This case should ideally not happen if logic is correct, but as safeguard:
              // console.log("Idle detected when processes might still be pending unexpectedly.");
            }
            // Add idle block only if no process is running and the simulation isn't finished
            if (completedProcessesCount < processes.length) {
              addGanttBlock(null, true);
            }
          }

          // C. Select next process if CPU is idle and queue isn't empty
          if (!runningProcessId && readyQueue.length > 0) {
            const nextProcessId = readyQueue.shift();
            runningProcessId = nextProcessId;
            const nextProc = findProcessById(runningProcessId);
            nextProc.state = "Running";
            nextProc.waitingTime += currentTime - nextProc._lastExecutionTime;
            if (nextProc.startTime === -1) {
              nextProc.startTime = currentTime;
            }
            updateProcessTableRow(nextProc);
            currentSliceTime = 0; // Start new slice timer
            stateChanged = true;
          }

          // D. Update UI elements if state changed
          if (stateChanged) {
            renderReadyQueue();
            renderCPU();
          }

          // E. Increment Clock
          currentTime++;
          clockDiv.textContent = currentTime;

          // F. Check for simulation end
          if (
            processes.length > 0 &&
            completedProcessesCount === processes.length
          ) {
            endSimulation();
          }
          // Add a safeguard timeout in case of infinite loops (e.g., bad input leading to weird state)
          else if (currentTime > 1000) {
            // Arbitrary large number
            console.error("Simulation exceeded max time limit. Terminating.");
            updateStatus("Error: Simulation exceeded time limit.", false);
            endSimulation(); // Force end
          }
        }

        // --- Simulation Controls ---
        function startSimulation() {
          if (simulationInterval) return;

          const tqValue = parseInt(timeQuantumInput.value, 10);
          if (isNaN(tqValue) || tqValue <= 0) {
            updateStatus(
              "Error: Please enter a positive integer Time Quantum.",
              false
            );
            return;
          }
          timeQuantum = tqValue;

          // Ensure processes are loaded (either custom or default)
          if (processes.length === 0 && customProcessesData.length === 0) {
            // If reset was hit and custom was cleared, reload defaults
            initializeSimulation();
          } else if (processes.length === 0 && customProcessesData.length > 0) {
            // If custom processes exist but haven't been loaded into `processes` yet
            initializeSimulation();
          }

          // Final check if there are actually processes to run
          if (processes.length === 0) {
            updateStatus(
              "Error: No processes defined. Add custom processes or Reset.",
              false
            );
            return;
          }

          isPaused = false;
          simulationInterval = setInterval(simulationStep, SIMULATION_SPEED_MS);

          // Disable inputs during simulation
          startButton.disabled = true;
          pauseButton.disabled = false;
          pauseButton.textContent = "Pause";
          timeQuantumInput.disabled = true;
          arrivalTimeInput.disabled = true;
          burstTimeInput.disabled = true;
          addProcessButton.disabled = true;
          clearProcessesButton.disabled = true;

          updateStatus("Simulation started...", true);
        }
        function pauseSimulation() {
          if (!simulationInterval && !isPaused) return;

          isPaused = !isPaused;
          if (isPaused) {
            pauseButton.textContent = "Resume";
            updateStatus(`Simulation paused at Time: ${currentTime}`, true);
          } else {
            pauseButton.textContent = "Pause";
            updateStatus("Simulation resumed...", true);
          }
        }
        function resetSimulation() {
          if (simulationInterval) {
            clearInterval(simulationInterval);
            simulationInterval = null;
          }
          // Don't clear customProcessesData here, initializeSimulation will handle it
          // Reset custom counter only if clearing manually
          initializeSimulation(); // Re-initializes state, UI, and enables inputs
        }
        function endSimulation() {
          if (simulationInterval) {
            clearInterval(simulationInterval);
            simulationInterval = null;
          }
          updateStatus(`Simulation finished at Time: ${currentTime}.`, true);
          startButton.disabled = true;
          pauseButton.disabled = true;
          pauseButton.textContent = "Pause";
          timeQuantumInput.disabled = true; // Keep controls disabled
          arrivalTimeInput.disabled = true; // Keep custom inputs disabled
          burstTimeInput.disabled = true;
          addProcessButton.disabled = true;
          clearProcessesButton.disabled = true;
          unhighlightProcessRow();
          renderMetrics();
        }

        // --- Utility ---
        function updateStatus(message, isInfo = true) {
          statusDiv.textContent = message;
          statusDiv.className = `status ${
            isInfo ? "status-info" : "status-error"
          }`;
          statusDiv.style.display = "none";
          statusDiv.offsetHeight; // Trigger reflow
          statusDiv.style.display = "";
          statusDiv.classList.add("visible");
        }

        // --- Initial Setup ---
        createDOM();
        // applyStyles(); // Styles are in the head now
        initializeSimulation(); // Set initial state and render
      });
    </script>
  </body>
</html>
