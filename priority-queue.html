<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Changed Title -->
    <title>Priority Scheduling (Non-Preemptive) Visualizer</title>
    <style id="dynamic-styles">
      /* --- Base Styles & Variables --- */
      :root {
        --bg-color: #f0f4f8; /* Lighter blue-gray */
        --container-bg: #ffffff;
        --section-bg: #ffffff; /* White cards */
        --header-color: #1a253c; /* Dark blue */
        --text-color: #334155; /* Slate gray */
        --border-color: #e2e8f0; /* Lighter border */
        --idle-color: #94a3b8; /* Slate */
        --ready-color: #f59e0b; /* Amber */
        --running-color: #10b981; /* Emerald */
        --terminated-color: #6b7280; /* Gray */
        --button-add: #3b82f6; /* Blue */
        --button-start: #22c55e; /* Green */
        --button-pause: #f59e0b; /* Amber */
        --button-reset: #ef4444; /* Red */
        --button-hover-factor: 0.9;
        --accent-blue: #3b82f6;

        --gantt-height: 45px;
        --queue-item-size: 38px;
        --base-font-size: 16px;
        --border-radius: 6px;
        --transition-speed: 0.25s;
        --box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --box-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
          sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        line-height: 1.6;
        font-size: var(--base-font-size);
        padding: 25px;
        display: flex;
        justify-content: center;
      }

      .container {
        background-color: var(--container-bg);
        padding: 30px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow-lg);
        width: 95%;
        max-width: 1300px; /* Wider layout */
        display: flex;
        flex-direction: column;
        gap: 25px; /* Spacing between main sections */
      }

      h1,
      h3,
      h4 {
        color: var(--header-color);
        margin-bottom: 10px; /* Reduced margin */
        text-align: center;
      }
      h1 {
        font-size: 1.8em;
        margin-bottom: 20px;
      }
      h3 {
        font-size: 1.3em;
        margin-top: 10px;
      }
      h4 {
        font-size: 1.1em;
        font-weight: 600;
        margin-bottom: 8px;
        text-align: left;
      }

      .section {
        background-color: var(--section-bg);
        padding: 20px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        border: 1px solid var(--border-color);
      }

      /* --- Add Process Form --- */
      .add-process-form {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: flex-end; /* Align items to bottom for button */
        padding: 15px 20px; /* Padding inside form */
        /* Removed bottom border, added full section styles */
      }
      .input-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .input-group label {
        font-weight: 600;
        font-size: 0.85em;
        color: var(--header-color);
      }
      .input-group input {
        padding: 7px 10px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        font-size: 0.95em;
        width: 80px; /* Smaller width for inputs */
      }
      .input-group input[type="text"] {
        width: 60px;
      }
      .input-group input:focus {
        outline: 2px solid var(--accent-blue);
        outline-offset: 1px;
        border-color: var(--accent-blue);
      }
      .input-group input:disabled {
        background-color: #e2e8f0;
        cursor: not-allowed;
      }

      /* --- Controls --- */
      .controls {
        display: flex;
        gap: 15px;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        padding-bottom: 15px; /* Space below controls */
        border-bottom: 1px solid var(--border-color);
      }

      .controls button,
      #add-process-button {
        padding: 9px 18px;
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 600;
        font-size: 0.95em;
        transition: background-color var(--transition-speed),
          transform 0.1s ease, filter var(--transition-speed);
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      }
      .controls button:disabled,
      #add-process-button:disabled {
        background-color: #cbd5e1 !important; /* Light slate */
        cursor: not-allowed;
        filter: grayscale(50%);
      }
      .controls button:not(:disabled):hover,
      #add-process-button:not(:disabled):hover {
        filter: brightness(var(--button-hover-factor));
      }
      .controls button:active:not(:disabled),
      #add-process-button:active:not(:disabled) {
        transform: scale(0.97);
        filter: brightness(calc(var(--button-hover-factor) * 0.95));
      }
      #add-process-button {
        background-color: var(--button-add);
        height: 35px; /* Match input height roughly */
        align-self: flex-end; /* Align with bottom of inputs */
      }
      #start-button {
        background-color: var(--button-start);
      }
      #pause-button {
        background-color: var(--button-pause);
      }
      #reset-button {
        background-color: var(--button-reset);
      }

      /* --- Status --- */
      .status {
        padding: 10px 15px;
        border-radius: var(--border-radius);
        text-align: center;
        font-weight: 600;
        font-size: 0.95em;
        min-height: 2em; /* Reserve space */
        transition: background-color var(--transition-speed),
          color var(--transition-speed), opacity var(--transition-speed);
        opacity: 0; /* Start hidden for fade-in */
        margin-top: 10px; /* Add some space above status */
      }
      .status.visible {
        opacity: 1;
      }
      .status-info {
        background-color: #ecfdf5;
        color: #059669;
        border: 1px solid #a7f3d0;
      } /* Lighter green */
      .status-success {
        background-color: #f0f9ff;
        color: #0284c7;
        border: 1px solid #bae6fd;
      } /* Lighter blue for success */
      .status-error {
        background-color: #fef2f2;
        color: #dc2626;
        border: 1px solid #fecaca;
      } /* Lighter red */

      /* --- Visualization Area Layout --- */
      .visualization-area {
        display: grid; /* Use Grid for more control */
        grid-template-columns: minmax(400px, 1.5fr) 2fr; /* Table | Queue/CPU/Gantt */
        gap: 25px;
      }
      .panel {
        display: flex;
        flex-direction: column;
        gap: 20px; /* Space between sections in a panel */
      }
      .panel h3 {
        margin-bottom: 15px;
      } /* Space below panel titles */

      /* --- Process Table --- */
      #process-table-container {
        overflow-x: auto;
      }
      .process-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
        white-space: nowrap; /* Prevent wrapping */
      }
      .process-table th,
      .process-table td {
        border: 1px solid var(--border-color);
        padding: 9px 12px; /* More padding */
        text-align: center;
      }
      .process-table th {
        background-color: #f8fafc; /* Very light gray header */
        color: var(--header-color);
        font-weight: 600;
      }
      .process-table tr:nth-child(even) {
        background-color: #f8fafc;
      }
      .process-table tr:hover {
        background-color: #eff6ff;
      } /* Light blue hover */

      .process-table td.state-cell {
        font-weight: 600;
        color: white;
        border-radius: 4px; /* Rounded badge */
        padding: 5px 8px; /* Padding inside state cell */
        transition: background-color var(--transition-speed) ease,
          color var(--transition-speed) ease;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);
      }
      .state-New {
        background-color: #e2e8f0 !important;
        color: var(--text-color) !important;
        text-shadow: none;
      } /* Lighter slate */
      .state-Ready {
        background-color: var(--ready-color) !important;
      }
      .state-Running {
        background-color: var(--running-color) !important;
      }
      .state-Terminated {
        background-color: var(--terminated-color) !important;
      }

      /* Highlight running process row */
      .process-table tr.highlight-running {
        background-color: #dcfce7 !important; /* Light green background */
        font-weight: bold;
      }
      .process-table tr.highlight-running td {
        color: #15803d; /* Darker green text */
      }
      .process-table tr.highlight-running td.state-cell {
        /* Ensure state badge overrides */
        color: white !important;
      }

      /* --- Ready Queue --- */
      #ready-queue {
        min-height: 60px;
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        padding: 15px;
        border: 1px dashed var(--border-color); /* Dashed border for queue */
        border-radius: var(--border-radius);
      }
      .queue-item {
        position: relative; /* Needed for priority badge */
        width: var(--queue-item-size);
        height: var(--queue-item-size);
        line-height: var(--queue-item-size);
        text-align: center;
        font-weight: 600;
        border-radius: var(--border-radius); /* Rounded square */
        color: white;
        background-color: var(--ready-color);
        box-shadow: var(--box-shadow);
        transition: transform var(--transition-speed) ease,
          opacity var(--transition-speed) ease;
        opacity: 0;
        transform: scale(0.8) translateY(10px); /* Start smaller and slightly lower */
      }
      .queue-item .priority-badge {
        /* Small badge for priority */
        position: absolute;
        top: -5px;
        right: -5px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        font-size: 0.7em;
        padding: 1px 4px;
        border-radius: 3px;
        line-height: 1.2;
      }
      .queue-item.visible {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      .queue-empty-text {
        width: 100%;
        text-align: center;
        color: var(--idle-color);
        font-style: italic;
      }

      /* --- CPU & Clock --- */
      .cpu-clock-container {
        display: grid;
        grid-template-columns: repeat(
          auto-fit,
          minmax(120px, 1fr)
        ); /* Responsive columns */
        gap: 15px;
        text-align: center;
      }
      .cpu-clock-item {
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
      }
      .cpu-clock-item h4 {
        margin-bottom: 10px;
        text-align: center;
      }
      .cpu-box,
      .clock-box {
        padding: 8px 15px;
        font-weight: 700; /* Bolder */
        font-size: 1.1em;
        border-radius: 4px;
        display: inline-block; /* Fit content */
        min-width: 60px;
        text-align: center;
      }
      .cpu-box {
        background-color: var(--idle-color);
        color: white;
        transition: background-color var(--transition-speed) ease,
          color var(--transition-speed) ease;
      }
      .cpu-box.running {
        background-color: var(--running-color);
      }
      .clock-box {
        background-color: #f8fafc;
        border: 1px solid var(--border-color);
        color: var(--header-color);
      }

      /* --- Gantt Chart --- */
      .gantt-section {
        padding-bottom: 35px;
        position: relative; /* Space for axis label */
      }
      .gantt-chart-container {
        height: calc(
          var(--gantt-height) + 25px
        ); /* Height + time labels + buffer */
        overflow-x: auto;
        overflow-y: hidden;
        padding: 10px 5px; /* Padding top/bottom */
        position: relative;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        background-color: #f8fafc; /* Light background for chart area */
        margin-top: 10px;
        max-width: 800px; /* Limit width for better viewing */
      }
      .gantt-chart-track {
        display: flex;
        height: var(--gantt-height);
        min-width: 100%;
        width: fit-content;
        position: relative; /* For time markers */
        border-left: 1px solid #999; /* Start line */
      }
      .gantt-block {
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 600; /* Slightly bolder */
        font-size: 0.9em;
        color: white;
        text-align: center;
        border-right: 1px solid rgba(0, 0, 0, 0.15); /* Subtle border */
        box-sizing: border-box;
        flex-shrink: 0;
        overflow: hidden;
        white-space: nowrap;
        border-radius: 3px; /* Slight rounding on blocks */
        margin: 1px 0; /* Tiny vertical margin */
        opacity: 0;
        animation: fade-in 0.4s ease forwards;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
      }
      @keyframes fade-in {
        to {
          opacity: 1;
        }
      }

      .gantt-block.idle {
        background-color: var(--idle-color);
        color: #e2e8f0;
      }
      .gantt-time-markers {
        position: absolute;
        bottom: 0px; /* Position markers right below the track */
        left: 5px; /* Align with track padding */
        width: calc(100% - 10px); /* Match track padding */
        height: 20px; /* Space for the numbers */
        margin-top: 5px; /* Space above markers */
      }
      .gantt-time-marker {
        position: absolute;
        bottom: 0;
        font-size: 0.8em;
        color: #475569; /* Darker gray for time */
        transform: translateX(-50%); /* Center the label */
        border-left: 1px solid #cbd5e1; /* Tick mark */
        height: 5px; /* Tick height */
        padding-left: 3px; /* Space text from tick */
      }
      .gantt-time-marker span {
        display: inline-block;
        transform: translateY(-18px); /* Position number above tick */
      }

      .gantt-axis-label {
        position: absolute;
        bottom: 0px; /* Below the markers */
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.85em;
        font-weight: 600;
        color: var(--header-color);
      }

      /* --- Metrics --- */
      .metrics {
        text-align: center;
      }
      .metrics p {
        font-weight: 600;
        font-size: 1.05em;
        color: var(--header-color);
        margin-bottom: 8px;
        background-color: #f8fafc;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid var(--border-color);
        display: inline-block; /* Fit content */
        min-width: 250px; /* Ensure decent width */
        margin-left: 10px;
        margin-right: 10px;
      }
      .metrics p span {
        font-weight: 700;
        color: var(--accent-blue); /* Highlight value */
      }

      /* --- Responsive Adjustments (Basic) --- */
      @media (max-width: 1100px) {
        .visualization-area {
          grid-template-columns: 1fr; /* Stack panels */
        }
      }
      @media (max-width: 768px) {
        body {
          padding: 15px;
        }
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 1.5em;
        }
        .add-process-form {
          justify-content: center; /* Center inputs on smaller screens */
        }
        .controls {
          flex-direction: column; /* Stack controls vertically */
          align-items: stretch; /* Stretch items */
          gap: 10px;
        }
        .controls button,
        #add-process-button {
          padding: 10px 16px; /* Slightly larger buttons */
          font-size: 1em;
        }
        .cpu-clock-container {
          grid-template-columns: 1fr;
        } /* Stack CPU/Clock */
        .metrics p {
          display: block; /* Stack metrics */
          margin-left: 0;
          margin-right: 0;
        }
        .gantt-chart-container {
          max-width: none; /* Allow gantt to take full width */
        }
      }
    </style>
  </head>
  <body>
    <!-- Structure will be created by JavaScript -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- Configuration ---
        const SIMULATION_SPEED_MS = 650; // Speed of each time unit

        // --- Initial Test Data (Includes Priority: lower number = higher priority) ---
        const initialProcessesData = [
          { id: "P1", arrivalTime: 0, burstTime: 8, priority: 3 },
          { id: "P2", arrivalTime: 1, burstTime: 4, priority: 1 }, // Higher priority
          { id: "P3", arrivalTime: 2, burstTime: 9, priority: 4 },
          { id: "P4", arrivalTime: 3, burstTime: 5, priority: 2 },
          { id: "P5", arrivalTime: 4, burstTime: 2, priority: 5 }, // Lowest priority
        ];
        let userAddedProcessesData = []; // Store custom processes separately

        // --- State Variables ---
        let processes = [];
        let readyQueue = []; // Stores process OBJECTS for sorting
        let ganttData = [];
        let currentTime = 0;
        let runningProcessId = null;
        let runningProcessRow = null; // For highlighting table row
        let completedProcessesCount = 0;
        let simulationInterval = null;
        let isPaused = false;
        let lastGanttEntry = null;

        // Colors for processes
        const processColors = [
          "#3b82f6",
          "#ef4444",
          "#10b981",
          "#f59e0b",
          "#8b5cf6",
          "#06b6d4",
          "#ec4899",
          "#65a30d",
          "#d97706",
          "#0ea5e9",
        ];

        // --- DOM Elements ---
        let container,
          addProcessForm,
          processIdInput,
          arrivalTimeInput,
          burstTimeInput,
          priorityInput,
          addProcessButton;
        let controlsDiv,
          visualizationDiv,
          processTableContainer,
          readyQueueDiv,
          cpuDiv,
          clockDiv,
          ganttChartContainer,
          ganttChartTrack,
          ganttTimeMarkersContainer,
          ganttAxisLabel,
          metricsDiv,
          statusDiv;
        let startButton, pauseButton, resetButton;

        // --- Core Functions ---

        // 1. Create DOM (Added Add Process Form, Removed TQ Input)
        function createDOM() {
          container = document.createElement("div");
          container.className = "container";

          const title = document.createElement("h1");
          title.textContent = "Priority Scheduling (Non-Preemptive) Visualizer"; // Changed Title
          container.appendChild(title);

          // --- Add Process Form ---
          addProcessForm = document.createElement("form");
          addProcessForm.className = "add-process-form section";
          addProcessForm.addEventListener("submit", (e) => e.preventDefault()); // Prevent default form submission

          const formTitle = document.createElement("h4");
          formTitle.textContent = "Add Custom Process";
          formTitle.style.width = "100%"; // Span full width
          formTitle.style.textAlign = "left";
          formTitle.style.marginBottom = "15px";
          addProcessForm.appendChild(formTitle);

          // Input Group Function
          const createInputGroup = (
            id,
            labelText,
            type = "number",
            placeholder = ""
          ) => {
            const group = document.createElement("div");
            group.className = "input-group";
            const label = document.createElement("label");
            label.htmlFor = id;
            label.textContent = labelText;
            const input = document.createElement("input");
            input.type = type;
            input.id = id;
            input.name = id;
            input.placeholder = placeholder;
            if (type === "number") {
              input.min = "0"; // Non-negative arrival, burst, priority
              input.step = "1";
            }
            group.appendChild(label);
            group.appendChild(input);
            return { group, input };
          };

          // Create Inputs
          const idGroup = createInputGroup("process-id", "ID", "text", "P6");
          processIdInput = idGroup.input;
          const arrivalGroup = createInputGroup(
            "arrival-time",
            "Arrival",
            "number",
            "5"
          );
          arrivalTimeInput = arrivalGroup.input;
          const burstGroup = createInputGroup(
            "burst-time",
            "Burst",
            "number",
            "4"
          );
          burstTimeInput = burstGroup.input;
          burstTimeInput.min = "1"; // Burst must be > 0
          const priorityGroup = createInputGroup(
            "priority",
            "Priority",
            "number",
            "3"
          );
          priorityInput = priorityGroup.input; // Lower number = higher priority

          // Add Button
          addProcessButton = document.createElement("button");
          addProcessButton.id = "add-process-button";
          addProcessButton.textContent = "Add Process";
          addProcessButton.type = "button"; // Important: Prevent form submission
          addProcessButton.addEventListener("click", handleAddProcess);

          addProcessForm.appendChild(idGroup.group);
          addProcessForm.appendChild(arrivalGroup.group);
          addProcessForm.appendChild(burstGroup.group);
          addProcessForm.appendChild(priorityGroup.group);
          addProcessForm.appendChild(addProcessButton);
          container.appendChild(addProcessForm);
          // --- End Add Process Form ---

          // Controls (Removed Time Quantum Input)
          controlsDiv = document.createElement("div");
          controlsDiv.className = "controls";

          startButton = document.createElement("button");
          startButton.id = "start-button";
          startButton.textContent = "Start";
          startButton.addEventListener("click", startSimulation);
          pauseButton = document.createElement("button");
          pauseButton.id = "pause-button";
          pauseButton.textContent = "Pause";
          pauseButton.disabled = true;
          pauseButton.addEventListener("click", pauseSimulation);
          resetButton = document.createElement("button");
          resetButton.id = "reset-button";
          resetButton.textContent = "Reset";
          resetButton.addEventListener("click", resetSimulation);

          controlsDiv.appendChild(startButton);
          controlsDiv.appendChild(pauseButton);
          controlsDiv.appendChild(resetButton);
          container.appendChild(controlsDiv);

          // Status Display
          statusDiv = document.createElement("div");
          statusDiv.className = "status"; // Removed default class
          statusDiv.id = "status-message";
          container.appendChild(statusDiv);

          // Visualization Area (Grid Layout) - Same structure
          visualizationDiv = document.createElement("div");
          visualizationDiv.className = "visualization-area";
          const leftPanel = document.createElement("div");
          leftPanel.className = "panel left-panel section";
          const tableTitle = document.createElement("h3");
          tableTitle.textContent = "Process Details";
          processTableContainer = document.createElement("div");
          processTableContainer.id = "process-table-container";
          leftPanel.appendChild(tableTitle);
          leftPanel.appendChild(processTableContainer);

          const rightPanel = document.createElement("div");
          rightPanel.className = "panel right-panel";
          const queueSection = document.createElement("div");
          queueSection.className = "section";
          const queueTitle = document.createElement("h3");
          queueTitle.textContent = "Ready Queue (Sorted by Priority)"; // Updated title
          readyQueueDiv = document.createElement("div");
          readyQueueDiv.id = "ready-queue";
          queueSection.appendChild(queueTitle);
          queueSection.appendChild(readyQueueDiv);

          const cpuClockSection = document.createElement("div");
          cpuClockSection.className = "section cpu-clock-container";
          const cpuItem = document.createElement("div");
          cpuItem.className = "cpu-clock-item";
          const cpuTitle = document.createElement("h4");
          cpuTitle.textContent = "CPU";
          cpuDiv = document.createElement("div");
          cpuDiv.id = "cpu-status";
          cpuDiv.className = "cpu-box idle";
          cpuDiv.textContent = "Idle";
          cpuItem.appendChild(cpuTitle);
          cpuItem.appendChild(cpuDiv);
          const clockItem = document.createElement("div");
          clockItem.className = "cpu-clock-item";
          const clockTitle = document.createElement("h4");
          clockTitle.textContent = "Clock";
          clockDiv = document.createElement("div");
          clockDiv.id = "clock";
          clockDiv.className = "clock-box";
          clockDiv.textContent = "0";
          clockItem.appendChild(clockTitle);
          clockItem.appendChild(clockDiv);
          cpuClockSection.appendChild(cpuItem);
          cpuClockSection.appendChild(clockItem);

          const ganttSection = document.createElement("div");
          ganttSection.className = "section gantt-section";
          const ganttTitle = document.createElement("h3");
          ganttTitle.textContent = "Gantt Chart";
          ganttChartContainer = document.createElement("div");
          ganttChartContainer.id = "gantt-chart";
          ganttChartContainer.className = "gantt-chart-container";
          ganttChartTrack = document.createElement("div");
          ganttChartTrack.className = "gantt-chart-track";
          ganttTimeMarkersContainer = document.createElement("div");
          ganttTimeMarkersContainer.className = "gantt-time-markers";
          ganttAxisLabel = document.createElement("div");
          ganttAxisLabel.className = "gantt-axis-label";
          ganttAxisLabel.textContent = "Time";
          ganttChartContainer.appendChild(ganttChartTrack);
          ganttChartContainer.appendChild(ganttTimeMarkersContainer);
          ganttSection.appendChild(ganttTitle);
          ganttSection.appendChild(ganttChartContainer);
          ganttSection.appendChild(ganttAxisLabel);

          metricsDiv = document.createElement("div");
          metricsDiv.id = "metrics";
          metricsDiv.className = "metrics section";
          metricsDiv.style.display = "none";

          rightPanel.appendChild(queueSection);
          rightPanel.appendChild(cpuClockSection);
          rightPanel.appendChild(ganttSection);
          rightPanel.appendChild(metricsDiv);
          visualizationDiv.appendChild(leftPanel);
          visualizationDiv.appendChild(rightPanel);
          container.appendChild(visualizationDiv);

          document.body.appendChild(container);
        }

        // 2. Inject CSS (Using <style> tag in head) - No change needed

        // 3. Initialize Simulation (Combines initial and user data)
        function initializeSimulation() {
          // Combine initial and user-added process data
          const allProcessData = [
            ...initialProcessesData,
            ...userAddedProcessesData,
          ];

          processes = JSON.parse(JSON.stringify(allProcessData)).map(
            (p, index) => ({
              ...p,
              id: p.id || `P${initialProcessesData.length + index + 1}`, // Generate unique ID if missing
              arrivalTime: Number(p.arrivalTime) || 0,
              burstTime: Number(p.burstTime) || 1,
              priority: Number(p.priority) || 99, // Default low priority if missing
              remainingBurstTime: Number(p.burstTime) || 1,
              state: "New",
              startTime: -1,
              completionTime: -1,
              waitingTime: 0,
              turnaroundTime: 0,
              _lastExecutionTime: Number(p.arrivalTime) || 0,
              _color: getProcessColor(
                p.id || `P${initialProcessesData.length + index + 1}`
              ),
            })
          );

          readyQueue = [];
          ganttData = [];
          currentTime = 0;
          runningProcessId = null;
          unhighlightProcessRow();
          completedProcessesCount = 0;
          lastGanttEntry = null;
          isPaused = false;

          if (simulationInterval) {
            clearInterval(simulationInterval);
            simulationInterval = null;
          }

          renderProcessTable();
          renderReadyQueue();
          renderCPU();
          renderGanttChart();
          clockDiv.textContent = "0";
          metricsDiv.innerHTML = "";
          metricsDiv.style.display = "none";
          updateStatus("Simulation reset. Add processes or press Start.", true);

          // Reset/Enable Controls
          startButton.disabled = false;
          pauseButton.textContent = "Pause";
          pauseButton.disabled = true;
          enableAddProcessForm(true);
        }

        // 4. Handle Add Process
        function handleAddProcess() {
          const id = processIdInput.value.trim();
          const arrivalTime = parseInt(arrivalTimeInput.value, 10);
          const burstTime = parseInt(burstTimeInput.value, 10);
          const priority = parseInt(priorityInput.value, 10);

          // --- Validation ---
          if (!id) {
            updateStatus("Error: Process ID cannot be empty.", false);
            return;
          }
          if (isNaN(arrivalTime) || arrivalTime < 0) {
            updateStatus(
              "Error: Arrival Time must be a non-negative integer.",
              false
            );
            return;
          }
          if (isNaN(burstTime) || burstTime <= 0) {
            updateStatus(
              "Error: Burst Time must be a positive integer.",
              false
            );
            return;
          }
          if (isNaN(priority) || priority < 0) {
            updateStatus(
              "Error: Priority must be a non-negative integer.",
              false
            );
            return;
          }

          // Check for duplicate ID (in both initial and user-added)
          const combinedData = [
            ...initialProcessesData,
            ...userAddedProcessesData,
          ];
          if (combinedData.some((p) => p.id === id)) {
            updateStatus(`Error: Process ID "${id}" already exists.`, false);
            return;
          }
          // --- End Validation ---

          const newProcess = { id, arrivalTime, burstTime, priority };
          userAddedProcessesData.push(newProcess);

          // Add to the live table immediately if simulation hasn't started
          if (!simulationInterval && !isPaused && currentTime === 0) {
            initializeSimulation(); // Re-initialize to include the new process in the main list and table
            updateStatus(
              `Process ${id} added successfully. Ready to start.`,
              true,
              "success"
            );
          } else {
            // If sim running/paused/finished, just update the table visually (it will be included on Reset)
            addProcessToTable(newProcess);
            updateStatus(
              `Process ${id} added. It will be included in the next simulation run after Reset.`,
              true,
              "info"
            );
          }

          // Clear form
          processIdInput.value = "";
          arrivalTimeInput.value = "";
          burstTimeInput.value = "";
          priorityInput.value = "";
          processIdInput.focus(); // Focus back on ID for next entry
        }

        // Helper to add a row to the table without full re-render (used after sim starts)
        function addProcessToTable(p) {
          const table = processTableContainer.querySelector(
            ".process-table tbody"
          );
          if (table) {
            const row = table.insertRow();
            row.id = `proc-row-${p.id}`;
            row.innerHTML = `
                    <td>${p.id}</td>
                    <td>${p.arrivalTime}</td>
                    <td>${p.burstTime}</td>
                    <td>${p.priority}</td>
                    <td class="remaining-time">${p.burstTime}</td>
                    <td class="state-cell state-New">New</td>
                    <td class="wait-time">0</td>
                    <td class="turnaround-time">-</td>
                `;
          }
        }

        // --- Rendering Functions (Added Priority Column) ---
        function renderProcessTable() {
          let tableHTML = `<table class="process-table"><thead><tr>
                    <th>ID</th><th>Arrival</th><th>Burst</th><th>Priority</th>
                    <th>Remain</th><th>State</th><th>Wait</th><th>TAT</th>
                </tr></thead><tbody>`; // Added Priority Col Header
          // Sort processes by ID for consistent table display
          const displayProcesses = [...processes].sort((a, b) =>
            a.id.localeCompare(b.id, undefined, { numeric: true })
          );

          displayProcesses.forEach((p) => {
            tableHTML += `<tr id="proc-row-${p.id}">
                        <td>${p.id}</td>
                        <td>${p.arrivalTime}</td>
                        <td>${p.burstTime}</td>
                        <td>${p.priority}</td>
                        <td class="remaining-time">${p.remainingBurstTime}</td>
                        <td class="state-cell state-${p.state}">${p.state}</td>
                        <td class="wait-time">${p.waitingTime}</td>
                        <td class="turnaround-time">${
                          p.turnaroundTime > 0 ? p.turnaroundTime : "-"
                        }</td>
                    </tr>`;
          });
          tableHTML += `</tbody></table>`;
          processTableContainer.innerHTML = tableHTML;
          unhighlightProcessRow(); // Ensure no row is highlighted initially
        }
        function renderReadyQueue() {
          readyQueueDiv.innerHTML = "";
          if (readyQueue.length === 0) {
            const emptyText = document.createElement("div");
            emptyText.className = "queue-empty-text";
            emptyText.textContent = "Queue Empty";
            readyQueueDiv.appendChild(emptyText);
          } else {
            // Display based on the current order in readyQueue (already sorted by priority)
            readyQueue.forEach((proc, index) => {
              const item = document.createElement("div");
              item.className = "queue-item";
              item.textContent = proc.id;
              item.style.backgroundColor = proc._color;
              item.title = `Priority: ${proc.priority}`; // Add tooltip for priority
              // Optional: Add a small visual badge for priority
              const badge = document.createElement("span");
              badge.className = "priority-badge";
              badge.textContent = proc.priority;
              item.appendChild(badge);
              readyQueueDiv.appendChild(item);
              // Add animation class with delay
              setTimeout(() => item.classList.add("visible"), 30 * index);
            });
          }
        }
        function renderCPU() {
          // Same as before
          unhighlightProcessRow();
          if (runningProcessId) {
            const proc = findProcessById(runningProcessId);
            cpuDiv.textContent = runningProcessId;
            cpuDiv.className = "cpu-box running";
            cpuDiv.style.backgroundColor = proc
              ? proc._color
              : "var(--running-color)";
            highlightProcessRow(runningProcessId);
          } else {
            cpuDiv.textContent = "Idle";
            cpuDiv.className = "cpu-box idle";
            cpuDiv.style.backgroundColor = "var(--idle-color)";
          }
        }
        function highlightProcessRow(processId) {
          // Same as before
          unhighlightProcessRow();
          runningProcessRow = document.getElementById(`proc-row-${processId}`);
          if (runningProcessRow) {
            runningProcessRow.classList.add("highlight-running");
          }
        }
        function unhighlightProcessRow() {
          // Same as before
          if (runningProcessRow) {
            runningProcessRow.classList.remove("highlight-running");
            runningProcessRow = null;
          }
        }
        function renderGanttChart() {
          // Same as before
          ganttChartTrack.innerHTML = "";
          ganttTimeMarkersContainer.innerHTML = "";
          if (ganttData.length === 0 && currentTime === 0) {
            addTimeMarker(0);
            return;
          }
          const blockPixelWidth = 30;
          let totalDuration = 0;
          const timePoints = new Set([0]);

          ganttData.forEach((block) => {
            const blockDiv = document.createElement("div");
            blockDiv.className = "gantt-block";
            const duration = block.end - block.start;
            blockDiv.style.width = `${duration * blockPixelWidth}px`;
            totalDuration = Math.max(totalDuration, block.end);
            timePoints.add(block.end);

            if (block.isIdle) {
              blockDiv.classList.add("idle");
              blockDiv.textContent = `Idle`;
              blockDiv.title = `Idle from ${block.start} to ${block.end}`;
            } else {
              const proc = findProcessById(block.processId);
              blockDiv.textContent = `${block.processId}`;
              blockDiv.style.backgroundColor = proc ? proc._color : "gray";
              blockDiv.title = `${block.processId} from ${block.start} to ${block.end}`;
            }
            ganttChartTrack.appendChild(blockDiv);
          });

          // Add markers only at intervals or significant points for clarity
          const sortedTimePoints = Array.from(timePoints).sort((a, b) => a - b);
          const markerStep = Math.max(1, Math.floor(totalDuration / 20)); // Aim for ~20 markers max
          let lastMarkerTime = -markerStep;
          sortedTimePoints.forEach((time) => {
            if (
              time === 0 ||
              time >= lastMarkerTime + markerStep ||
              time === totalDuration
            ) {
              addTimeMarker(time, blockPixelWidth);
              lastMarkerTime = time;
            }
          });
          // Ensure last time point always has a marker if missed
          if (lastMarkerTime < totalDuration && totalDuration > 0) {
            addTimeMarker(totalDuration, blockPixelWidth);
          }

          ganttChartTrack.style.minWidth = `${
            totalDuration * blockPixelWidth + 2
          }px`; // +2 for border
          ganttChartContainer.scrollLeft = ganttChartTrack.scrollWidth;
        }
        function addTimeMarker(time, pixelWidth = 30) {
          // Same as before
          const marker = document.createElement("div");
          marker.className = "gantt-time-marker";
          marker.style.left = `${time * pixelWidth}px`;
          const markerLabel = document.createElement("span");
          markerLabel.textContent = time;
          marker.appendChild(markerLabel);
          ganttTimeMarkersContainer.appendChild(marker);
        }
        function renderMetrics() {
          // Same as before
          if (
            completedProcessesCount !== processes.length ||
            processes.length === 0
          )
            return;
          let totalWT = 0,
            totalTAT = 0;
          processes.forEach((p) => {
            totalWT += p.waitingTime;
            totalTAT += p.turnaroundTime;
          });
          const avgWT = (totalWT / processes.length).toFixed(2);
          const avgTAT = (totalTAT / processes.length).toFixed(2);
          metricsDiv.innerHTML = `
              <h3>Performance Metrics</h3>
              <p>Avg. Waiting Time: <span>${avgWT}</span></p>
              <p>Avg. Turnaround Time: <span>${avgTAT}</span></p>`;
          metricsDiv.style.display = "block"; // Show metrics
        }
        function updateProcessTableRow(process) {
          // Same as before (Priority doesn't change)
          const row = document.getElementById(`proc-row-${process.id}`);
          if (row) {
            row.querySelector(".remaining-time").textContent =
              process.remainingBurstTime;
            const stateCell = row.querySelector(".state-cell");
            stateCell.textContent = process.state;
            stateCell.className = `state-cell state-${process.state}`;
            row.querySelector(".wait-time").textContent = process.waitingTime;
            row.querySelector(".turnaround-time").textContent =
              process.completionTime !== -1 ? process.turnaroundTime : "-";
          }
        }
        function getProcessColor(processId) {
          // Same as before
          if (!processId || processId === "Idle") return "var(--idle-color)";
          try {
            // Attempt to extract number for consistent coloring
            const match = processId.match(/\d+/);
            const num = match
              ? parseInt(match[0], 10)
              : processId.charCodeAt(0); // Fallback if no number
            return processColors[
              (num - 1 + processColors.length) % processColors.length
            ];
          } catch (e) {
            return processColors[0]; // Default color
          }
        }
        function findProcessById(id) {
          // Same as before
          return processes.find((p) => p.id === id);
        }
        function addGanttBlock(processId, isIdle) {
          // Same as before
          const currentEntry = { id: processId, isIdle: isIdle };
          if (
            ganttData.length > 0 &&
            lastGanttEntry &&
            lastGanttEntry.id === currentEntry.id &&
            lastGanttEntry.isIdle === currentEntry.isIdle &&
            ganttData[ganttData.length - 1].end === currentTime // Ensure continuity
          ) {
            ganttData[ganttData.length - 1].end = currentTime + 1;
          } else {
            ganttData.push({
              processId: processId,
              start: currentTime,
              end: currentTime + 1,
              isIdle: isIdle,
            });
          }
          lastGanttEntry = { id: processId, isIdle: isIdle }; // Update last entry type *after* potentially modifying
          renderGanttChart();
        }

        // --- Simulation Logic (Priority Implementation) ---

        // 11. Simulation Step
        function simulationStep() {
          if (isPaused || completedProcessesCount === processes.length) return;

          let stateChanged = false; // Flag for UI updates

          // A. Check for new arrivals & add to ready queue
          let newArrivals = false;
          processes.forEach((p) => {
            if (p.state === "New" && p.arrivalTime <= currentTime) {
              p.state = "Ready";
              p._lastExecutionTime = currentTime; // Time it became ready
              readyQueue.push(p); // Add the process object
              updateProcessTableRow(p);
              stateChanged = true;
              newArrivals = true;
            }
          });

          // B. Sort Ready Queue if new processes arrived or if currently idle (to ensure order)
          // Sort by priority (lower number first), then arrival time (FCFS for ties)
          if (newArrivals || (!runningProcessId && readyQueue.length > 1)) {
            // Only sort if needed
            readyQueue.sort((a, b) => {
              if (a.priority !== b.priority) {
                return a.priority - b.priority; // Lower priority number first
              }
              return a.arrivalTime - b.arrivalTime; // FCFS for tie-break
            });
            if (newArrivals) stateChanged = true; // Queue order might change visuals
          }

          // C. Handle running process (Non-Preemptive: runs until completion)
          if (runningProcessId) {
            const runningProc = findProcessById(runningProcessId);
            runningProc.remainingBurstTime--;
            addGanttBlock(runningProc.id, false); // Add to Gantt Chart
            updateProcessTableRow(runningProc); // Update remaining time in table

            // Check for Completion
            if (runningProc.remainingBurstTime === 0) {
              runningProc.state = "Terminated";
              runningProc.completionTime = currentTime + 1;
              runningProc.turnaroundTime =
                runningProc.completionTime - runningProc.arrivalTime;
              // Final waiting time calculation
              runningProc.waitingTime =
                runningProc.turnaroundTime - runningProc.burstTime;
              updateProcessTableRow(runningProc);
              completedProcessesCount++;
              runningProcessId = null; // Free the CPU
              stateChanged = true;
              renderMetrics(); // Render metrics as soon as last process finishes
            }
            // NO Preemption check needed for non-preemptive priority
          } else {
            // CPU is Idle
            addGanttBlock(null, true); // Add Idle block to Gantt
          }

          // D. Select next process if CPU is idle and queue isn't empty
          if (!runningProcessId && readyQueue.length > 0) {
            const nextProcess = readyQueue.shift(); // Get highest priority from sorted queue
            runningProcessId = nextProcess.id;
            nextProcess.state = "Running";

            // Calculate waiting time incurred *since it was last ready*
            // Ensure waiting time doesn't decrease (can happen with edge cases if not careful)
            const waitIncrement = Math.max(
              0,
              currentTime - nextProcess._lastExecutionTime
            );
            nextProcess.waitingTime += waitIncrement;

            if (nextProcess.startTime === -1) {
              nextProcess.startTime = currentTime; // Record first start time
            }
            updateProcessTableRow(nextProcess);
            stateChanged = true;
          }

          // E. Update UI elements if state changed
          if (stateChanged) {
            renderReadyQueue(); // Update queue display (reflects sorted order)
            renderCPU(); // Update CPU status box
          }

          // F. Increment Clock
          currentTime++;
          clockDiv.textContent = currentTime;

          // G. Check for simulation end
          if (
            completedProcessesCount === processes.length &&
            processes.length > 0
          ) {
            // Already handled in step C, but double-check
            endSimulation();
          } else if (processes.length === 0 && currentTime > 0) {
            // Handle case where no processes were added
            endSimulation();
          }
        }

        // --- Simulation Controls ---
        function startSimulation() {
          if (simulationInterval) return; // Already running

          // If starting from scratch or after reset, ensure initialization includes latest user processes
          if (currentTime === 0 && !isPaused) {
            initializeSimulation(); // Re-init to capture any last-minute process additions
          }

          // Don't start if there are no processes
          if (processes.length === 0) {
            updateStatus("Cannot start: No processes added.", false);
            return;
          }

          isPaused = false;
          simulationInterval = setInterval(simulationStep, SIMULATION_SPEED_MS);
          startButton.disabled = true;
          pauseButton.disabled = false;
          pauseButton.textContent = "Pause";
          enableAddProcessForm(false); // Disable add process form while running
          updateStatus("Simulation started...", true);
        }
        function pauseSimulation() {
          // Same as before
          if (
            !simulationInterval &&
            !isPaused &&
            completedProcessesCount === processes.length
          )
            return; // Don't pause if finished

          isPaused = !isPaused;
          if (isPaused) {
            if (simulationInterval) clearInterval(simulationInterval); // Clear interval on pause
            simulationInterval = null;
            pauseButton.textContent = "Resume";
            updateStatus(`Simulation paused at Time: ${currentTime}`, true);
            enableAddProcessForm(false); // Keep disabled during pause
          } else {
            // Restart the interval on resume
            simulationInterval = setInterval(
              simulationStep,
              SIMULATION_SPEED_MS
            );
            pauseButton.textContent = "Pause";
            updateStatus("Simulation resumed...", true);
            enableAddProcessForm(false); // Still disabled when resumed
          }
        }
        function resetSimulation() {
          if (simulationInterval) {
            clearInterval(simulationInterval);
            simulationInterval = null;
          }
          // Re-initialize, which now includes user-added processes
          initializeSimulation();
          enableAddProcessForm(true); // Re-enable form on reset
        }
        function endSimulation() {
          if (simulationInterval) {
            clearInterval(simulationInterval);
            simulationInterval = null;
          }
          // Don't show success message if no processes ran
          if (currentTime > 0 || processes.length > 0) {
            updateStatus(
              `Simulation finished at Time: ${currentTime}.`,
              true,
              "success"
            );
          } else {
            updateStatus(
              "Simulation ended (no processes to run).",
              true,
              "info"
            );
          }

          startButton.disabled = true;
          pauseButton.disabled = true;
          pauseButton.textContent = "Pause";
          enableAddProcessForm(false); // Keep add form disabled after finish
          unhighlightProcessRow(); // Ensure no row is highlighted
          renderMetrics(); // Calculate and display final metrics
        }

        // --- Utility ---
        function enableAddProcessForm(enable) {
          processIdInput.disabled = !enable;
          arrivalTimeInput.disabled = !enable;
          burstTimeInput.disabled = !enable;
          priorityInput.disabled = !enable;
          addProcessButton.disabled = !enable;
        }

        function updateStatus(message, isGood = true, type = "info") {
          statusDiv.textContent = message;
          let statusClass = "status-info"; // Default
          if (!isGood) {
            statusClass = "status-error";
          } else if (type === "success") {
            statusClass = "status-success";
          }

          statusDiv.className = `status ${statusClass}`;
          // Force reflow to restart animation if message repeats
          statusDiv.style.display = "none";
          statusDiv.offsetHeight; // Trigger reflow
          statusDiv.style.display = "";
          statusDiv.classList.add("visible");

          // Auto-hide info/success messages after a delay
          if (isGood && type !== "error") {
            // Don't auto-hide errors
            setTimeout(() => {
              if (statusDiv.textContent === message) {
                // Only hide if message hasn't changed
                statusDiv.classList.remove("visible");
              }
            }, 4000); // Hide after 4 seconds
          }
        }

        // --- Initial Setup ---
        createDOM();
        // applyStyles(); // Styles are in <style> tag
        initializeSimulation(); // Set initial state and render
      });
    </script>
  </body>
</html>
